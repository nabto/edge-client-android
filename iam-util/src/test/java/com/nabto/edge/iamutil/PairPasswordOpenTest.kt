package com.nabto.edge.iamutil

import com.nabto.edge.client.Coap
import com.nabto.edge.client.Connection
import com.nabto.edge.client.ErrorCode
import com.nabto.edge.client.ErrorCodes
import com.nabto.edge.client.NabtoCallback
import com.nabto.edge.client.NabtoRuntimeException
import com.nabto.edge.iamutil.mocks.createCoapMock
import com.nabto.edge.iamutil.mocks.createGetPairingCoapMock
import com.nabto.edge.iamutil.mocks.mockErrorCodes
import io.mockk.every
import io.mockk.mockk
import kotlinx.serialization.Serializable
import kotlinx.serialization.cbor.Cbor
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import java.util.Optional
import kotlin.test.assertFailsWith

@kotlinx.serialization.ExperimentalSerializationApi
class PairLocalOpenTest {
    val connection : Connection = mockk<Connection>();
    val iamUtil = IamUtil.create()
    val username = "testuser"
    val password = "testpassword"

    @Before
    fun setup() {
        every { connection.createCoap("GET", "/iam/pairing" ) } returns ( createGetPairingCoapMock() )
        mockErrorCodes()
    }

    @Serializable
    class PairingLocalOpenRequestData {
        val Username : String = ""
    }

    fun mockPairingPasswordOpenCall(statusCode : Int) {
        val coap = createCoapMock()
        every { coap.setRequestPayload(60, any()) } answers {
            val bytes = secondArg<ByteArray>()
            val request : PairingLocalOpenRequestData = Cbor{ignoreUnknownKeys = true}.decodeFromByteArray<PairingLocalOpenRequestData>(
                PairingLocalOpenRequestData.serializer(), bytes)
            assertEquals(request.Username, username);
        }
        every { coap.responseStatusCode } returns statusCode

        every { connection.createCoap("POST", "/iam/pairing/password-open" ) } returns coap
    }

    fun mockPasswordAuthenticate() {
        every { connection.passwordAuthenticate("", password) } returns Unit
    }

    fun mockPasswordAuthenticateCallback() {
        every { connection.passwordAuthenticateCallback("", password, any()) } answers {
            val callback = thirdArg<NabtoCallback<Unit>>()
            callback.run(0, Optional.empty())
        }
    }

    fun mockPasswordAuthenticateError(errorCodeInt : Int) {
        val runtimeException = mockk<NabtoRuntimeException>();
        //every { runtimeException.cause } returns null
        val errorCode = mockk<ErrorCode>()
        every { errorCode.errorCode } returns errorCodeInt

        every { runtimeException.errorCode } returns errorCode
        every { connection.passwordAuthenticate("", password) } throws runtimeException
    }

    @Test
    fun ok() {
        mockPasswordAuthenticate()
        mockPairingPasswordOpenCall(201)
        iamUtil.pairPasswordOpen(connection, username, password);
    }

    @Test
    fun badRequest() {
        mockPasswordAuthenticate()
        mockPairingPasswordOpenCall(400)
        val exception = assertFailsWith<IamException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getError(), IamError.INVALID_INPUT)
    }
    /*
    @Test
    fun blockedMissingPasswordAuthenticate() {
        mockPasswordAuthenticate()
        mockPairingPasswordOpenCall(401)
        val exception = assertFailsWith<IamException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getError(), IamError.AUTHENTICATION_ERROR)
    }*/
    @Test
    fun blockedByIam() {
        mockPasswordAuthenticate()
        mockPairingPasswordOpenCall(403)
        val exception = assertFailsWith<IamException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getError(), IamError.BLOCKED_BY_DEVICE_CONFIGURATION)
    }
    @Test
    fun modeDisabled() {
        mockPasswordAuthenticate()
        mockPairingPasswordOpenCall(404)
        val exception = assertFailsWith<IamException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getError(), IamError.PAIRING_MODE_DISABLED)
    }
    @Test
    fun usernameExists() {
        mockPasswordAuthenticate()
        mockPairingPasswordOpenCall(409)
        val exception = assertFailsWith<IamException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getError(), IamError.USERNAME_EXISTS)
    }

    @Test
    fun passwordAuthenticateTimeout() {
        mockPasswordAuthenticateError(ErrorCodes.TIMEOUT)
        mockPairingPasswordOpenCall(409)
        val exception = assertFailsWith<NabtoRuntimeException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getErrorCode().getErrorCode(), ErrorCodes.TIMEOUT)
    }

    @Test
    fun passwordAuthenticateNOT_CONNECTED() {
        mockPasswordAuthenticateError(ErrorCodes.NOT_CONNECTED)
        mockPairingPasswordOpenCall(409)

        val exception = assertFailsWith<NabtoRuntimeException> {
            iamUtil.pairPasswordOpen(connection, username, password);
        }
        assertEquals(exception.getErrorCode().getErrorCode(), ErrorCodes.NOT_CONNECTED)
    }

    @Test
    fun testThatPasswordAuthenticateCallbackIsUsed()
    {
        mockPasswordAuthenticateCallback()
        mockPairingPasswordOpenCall(201)
        iamUtil.pairPasswordOpenCallback(connection, username, password, { iamError: IamError, _ : Optional<Any> ->
            run {
                assertEquals(IamError.NONE, iamError)
            }
        })
    }

}
